{"ast":null,"code":"/*!\n * Youtube-video-js v3.1.4\n * https://github.com/mkay581/youtube-video-js#readme\n *\n * Copyright (c) 2019 Mark Kennedy\n * Licensed under the MIT license\n */\n\n/**\n * Makes sure that a path is converted to an array.\n * @param paths\n * @returns {*}\n */\nlet ensurePathArray = function (paths) {\n  if (!paths) {\n    paths = [];\n  } else if (typeof paths === 'string') {\n    paths = [paths];\n  }\n\n  return paths;\n};\n/**\n The Resource Manager.\n @class ResourceManager\n @description Represents a manager that loads any CSS and Javascript Resources on the fly.\n */\n\n\nclass ResourceManager {\n  /**\n   * Upon initialization.\n   * @memberOf ResourceManager\n   */\n  constructor() {\n    this._head = document.getElementsByTagName('head')[0];\n    this._cssPaths = {};\n    this._scriptMaps = {};\n    this._dataPromises = {};\n  }\n  /**\n   * Loads a javascript file.\n   * @param {string|Array} paths - The path to the view's js file\n   * @memberOf ResourceManager\n   * @return {Promise} Returns a promise that resolves when all scripts have been loaded\n   */\n\n\n  async loadScript(paths) {\n    let script,\n        map,\n        loadPromises = [];\n    paths = ensurePathArray(paths);\n    paths.forEach(path => {\n      map = this._scriptMaps[path] = this._scriptMaps[path] || {};\n\n      if (!map.promise) {\n        map.path = path;\n        map.promise = new Promise(resolve => {\n          script = this.createScriptElement();\n          script.setAttribute('type', 'text/javascript');\n          script.src = path;\n          script.addEventListener('load', resolve);\n\n          this._head.appendChild(script);\n        });\n      }\n\n      loadPromises.push(map.promise);\n    });\n    return Promise.all(loadPromises);\n  }\n  /**\n   * Removes a script that has the specified path from the head of the document.\n   * @param {string|Array} paths - The paths of the scripts to unload\n   * @memberOf ResourceManager\n   */\n\n\n  async unloadScript(paths) {\n    let file;\n    return new Promise(resolve => {\n      paths = ensurePathArray(paths);\n      paths.forEach(path => {\n        file = this._head.querySelectorAll('script[src=\"' + path + '\"]')[0];\n\n        if (file) {\n          this._head.removeChild(file);\n\n          delete this._scriptMaps[path];\n        }\n      });\n      resolve();\n    });\n  }\n  /**\n   * Creates a new script element.\n   * @returns {HTMLElement}\n   */\n\n\n  createScriptElement() {\n    return document.createElement('script');\n  }\n  /**\n   * Makes a request to get data and caches it.\n   * @param {string} url - The url to fetch data from\n   * @param [reqOptions] - options to be passed to fetch call\n   * @returns {*}\n   */\n\n\n  async fetchData(url, reqOptions = {}) {\n    let cacheId = url + JSON.stringify(reqOptions);\n    reqOptions.cache = reqOptions.cache === undefined ? true : reqOptions.cache;\n\n    if (!url) {\n      return Promise.resolve();\n    }\n\n    if (!this._dataPromises[cacheId] || !reqOptions.cache) {\n      try {\n        this._dataPromises[cacheId] = await fetch(url, reqOptions);\n      } catch (e) {\n        // if failure, remove cache so that subsequent\n        // requests will trigger new ajax call\n        this._dataPromises[cacheId] = null;\n        throw e;\n      }\n    }\n\n    return this._dataPromises[cacheId];\n  }\n  /**\n   * Loads css files.\n   * @param {Array|String} paths - An array of css paths files to load\n   * @memberOf ResourceManager\n   * @return {Promise}\n   */\n\n\n  async loadCss(paths) {\n    return new Promise(resolve => {\n      paths = ensurePathArray(paths);\n      paths.forEach(path => {\n        // TODO: figure out a way to find out when css is guaranteed to be loaded,\n        // and make this return a truely asynchronous promise\n        if (!this._cssPaths[path]) {\n          let el = document.createElement('link');\n          el.setAttribute('rel', 'stylesheet');\n          el.setAttribute('href', path);\n\n          this._head.appendChild(el);\n\n          this._cssPaths[path] = el;\n        }\n      });\n      resolve();\n    });\n  }\n  /**\n   * Unloads css paths.\n   * @param {string|Array} paths - The css paths to unload\n   * @memberOf ResourceManager\n   * @return {Promise}\n   */\n\n\n  async unloadCss(paths) {\n    let el;\n    return new Promise(resolve => {\n      paths = ensurePathArray(paths);\n      paths.forEach(path => {\n        el = this._cssPaths[path];\n\n        if (el) {\n          this._head.removeChild(el);\n\n          this._cssPaths[path] = null;\n        }\n      });\n      resolve();\n    });\n  }\n  /**\n   * Parses a template into a DOM element, then returns element back to you.\n   * @param {string} path - The path to the template\n   * @param {HTMLElement} [el] - The element to attach template to\n   * @returns {Promise} Returns a promise that resolves with contents of template file\n   */\n\n\n  async loadTemplate(path, el) {\n    if (!path) {\n      return Promise.resolve();\n    }\n\n    const contents = await this.fetchTemplate(path);\n\n    if (el) {\n      el.innerHTML = contents;\n      return el;\n    }\n\n    return contents;\n  }\n  /**\n   * Fetches a template file from the server.\n   * @param [templatePath] - The file path to the template file\n   * @returns {Promise} Returns a promise that is resolved with the contents of the template file when retrieved\n   */\n\n\n  async fetchTemplate(templatePath) {\n    const resp = await fetch(templatePath);\n    return await resp.text();\n  }\n  /**\n   * Removes all cached resources.\n   * @memberOf ResourceManager\n   */\n\n\n  async flush() {\n    await this.unloadCss(Object.getOwnPropertyNames(this._cssPaths));\n    this._cssPaths = {};\n\n    for (let s in this._scriptMaps) {\n      if (this._scriptMaps.hasOwnProperty(s)) {\n        let map = this._scriptMaps[s];\n        await this.unloadScript(map.path);\n      }\n    }\n\n    this._scriptMaps = {};\n    this._dataPromises = {};\n  }\n\n}\n\nconst resourceManager = new ResourceManager();\nconst videos = new Map();\n\nclass YoutubeVideoElement extends HTMLElement {\n  constructor() {\n    super();\n    this.paused = true;\n    this.ytPlayerContainer = undefined;\n    this.resolveBuildPlayerPromise = null;\n    this.ytPlayerPromise = null;\n    this.scriptPath = 'https://www.youtube.com/iframe_api';\n    this.mediaError = undefined;\n    videos.set(this, this.id);\n  }\n\n  connectedCallback() {\n    this.ytPlayerContainer = this.createYTPlayerElement();\n    this.appendChild(this.ytPlayerContainer);\n    this.ytPlayerContainer.style.display = 'block'; // to adhere to shape of youtube's generated iframe\n\n    this.load();\n  }\n\n  disconnectedCallback() {\n    videos.delete(this);\n\n    if (this.resolveBuildPlayerPromise) {\n      this.resolveBuildPlayerPromise();\n    }\n\n    if (this.ytPlayer) {\n      this.ytPlayer.destroy();\n    }\n\n    if (!videos.size) {\n      videos.clear();\n      this.unloadYTScript();\n    }\n  }\n\n  get height() {\n    return Number(this.getAttribute('height'));\n  }\n\n  get width() {\n    return Number(this.getAttribute('width'));\n  }\n\n  get src() {\n    return this.getAttribute('src');\n  }\n\n  get autoplay() {\n    return this.hasAttribute('autoplay');\n  }\n\n  get playsinline() {\n    return this.hasAttribute('playsinline');\n  }\n\n  get id() {\n    return this.getAttribute('id') || \"ytPlayer-\".concat(videos.size);\n  }\n\n  get controls() {\n    return this.hasAttribute('controls') || true;\n  }\n\n  get ytPlayerVars() {\n    const srcQueryParams = this.srcQueryParams;\n    srcQueryParams.autoplay = this.autoplay ? 1 : 0;\n    srcQueryParams.controls = this.controls ? 1 : 0;\n    srcQueryParams.playsinline = this.playsinline ? 1 : 0;\n    return srcQueryParams;\n  }\n\n  get srcQueryParams() {\n    const queryString = this.src.split('?')[1] || '';\n\n    if (!queryString) {\n      return {};\n    }\n\n    const a = queryString.split('&');\n    const params = {};\n\n    for (const item of a) {\n      const p = item.split('=', 2);\n\n      if (p.length === 1) {\n        params[p[0]] = '';\n      } else {\n        params[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, ' '));\n      }\n    }\n\n    return params;\n  }\n\n  async load() {\n    await this.loadYTScript();\n    this.ytPlayer = await this.buildPlayer();\n    return this.ytPlayer;\n  }\n\n  get videoId() {\n    const re = new RegExp(\"https?:\\\\/\\\\/(?:[0-9A-Z-]+\\\\.)?(?:youtu\\\\.be\\\\/|youtube(?:-nocookie)?\\\\.com\\\\S*[^\\\\w\\\\s-])([\\\\w-]{11})(?=[^\\\\w-]|$)(?![?=&+%\\\\w.-]*(?:['\\\"][^<>]*>|<\\\\/a>))[?=&+%\\\\w.-]*\", 'ig');\n    return this.src.replace(re, '$1');\n  }\n\n  play() {\n    this.paused = false;\n\n    if (!this.src) {\n      this.error = new Error(\"you cannot call play() method on a video element that has no youtube source url\");\n    } else if (this.ytPlayer) {\n      this.ytPlayer.playVideo();\n    }\n  }\n\n  pause() {\n    if (this.ytPlayer) {\n      this.ytPlayer.pauseVideo();\n    }\n  }\n\n  createYTPlayerElement() {\n    return document.createElement('div');\n  }\n\n  onPlay() {\n    this.paused = false; // pause all other youtube videos from playing!\n\n    videos.forEach((id, video) => {\n      if (video !== this && !video.paused) {\n        video.pause();\n      }\n    });\n    this.dispatchEvent(new CustomEvent('play'));\n  }\n\n  onPause() {\n    this.paused = true;\n  }\n\n  onEnd() {\n    this.paused = true;\n  }\n\n  set error(error) {\n    const message = error.message;\n    this.dispatchEvent(new ErrorEvent(message));\n    this.mediaError = error;\n    throw error;\n  }\n\n  get error() {\n    return this.mediaError;\n  }\n\n  _onYTApiStateChange(obj) {\n    const stateMap = {\n      '-1': 'unstarted',\n      '0': 'ended',\n      '1': 'playing',\n      '2': 'pause',\n      '3': 'buffering',\n      '5': 'cued'\n    };\n    const state = stateMap[obj.data.toString()]; // trigger our internal event handling method\n    // whenever the youtube api player triggers an event\n\n    const eventMethodMap = {\n      ended: this.onEnd,\n      pause: this.onPause,\n      playing: this.onPlay\n    };\n\n    if (eventMethodMap[state]) {\n      const method = eventMethodMap[state];\n\n      if (method) {\n        method.call(this); // TODO: trigger 'play' MediaEvent if the video has been paused at least once\n\n        this.dispatchEvent(new CustomEvent(state));\n      }\n    }\n  }\n\n  loadYTScript() {\n    // Load the IFrame Player API code asynchronously.\n    if (!YoutubeVideoElement.scriptLoadPromise) {\n      YoutubeVideoElement.scriptLoadPromise = new Promise(resolve => {\n        // NOTE: youtube's iframe api ready only fires once after first script load\n        if (!window.onYouTubeIframeAPIReady) {\n          YoutubeVideoElement.triggerYoutubeIframeAPIReady = resolve;\n\n          window.onYouTubeIframeAPIReady = () => {\n            window.onYouTubeIframeAPIReady = null; // once the script loads once, we are guaranteed for it to\n            // be ready even after destruction of all instances (if consumer\n            // doesnt mangle with it)\n\n            YoutubeVideoElement.triggerYoutubeIframeAPIReady();\n          };\n        }\n\n        return resourceManager.loadScript(this.scriptPath);\n      });\n    }\n\n    return YoutubeVideoElement.scriptLoadPromise;\n  }\n\n  unloadYTScript() {\n    resourceManager.unloadScript(this.scriptPath);\n    YoutubeVideoElement.scriptLoadPromise = null;\n  }\n\n  buildPlayer() {\n    if (this.ytPlayerPromise) {\n      return this.ytPlayerPromise;\n    }\n\n    this.ytPlayerPromise = new Promise(resolve => {\n      const playerOptions = {\n        events: {\n          onError: () => {\n            this.error = new Error('player could not be built');\n          },\n          onReady: e => {\n            this.dispatchEvent(new CustomEvent('loadstart'));\n            this.dispatchEvent(new CustomEvent('canplay'));\n            this.resolveBuildPlayerPromise = resolve;\n            resolve(e.target);\n          },\n          onStateChange: obj => this._onYTApiStateChange(obj)\n        },\n        height: this.height,\n        playerVars: this.ytPlayerVars,\n        videoId: this.videoId,\n        width: this.width\n      };\n      this.ytPlayer = new YT.Player( // @ts-ignore\n      this.ytPlayerContainer, playerOptions);\n    });\n    return this.ytPlayerPromise;\n  }\n\n}\n\nYoutubeVideoElement.scriptLoadPromise = null;\nYoutubeVideoElement.triggerYoutubeIframeAPIReady = null;\ncustomElements.define('youtube-video', YoutubeVideoElement);\nexport { YoutubeVideoElement };","map":null,"metadata":{},"sourceType":"module"}