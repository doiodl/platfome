{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _wrapNativeSuper from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _regeneratorRuntime from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/timurzajnullin/Desktop/platfome/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*!\n * Youtube-video-js v3.1.4\n * https://github.com/mkay581/youtube-video-js#readme\n *\n * Copyright (c) 2019 Mark Kennedy\n * Licensed under the MIT license\n */\n\n/**\n * Makes sure that a path is converted to an array.\n * @param paths\n * @returns {*}\n */\nvar ensurePathArray = function ensurePathArray(paths) {\n  if (!paths) {\n    paths = [];\n  } else if (typeof paths === 'string') {\n    paths = [paths];\n  }\n\n  return paths;\n};\n/**\n The Resource Manager.\n @class ResourceManager\n @description Represents a manager that loads any CSS and Javascript Resources on the fly.\n */\n\n\nvar ResourceManager =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Upon initialization.\n   * @memberOf ResourceManager\n   */\n  function ResourceManager() {\n    _classCallCheck(this, ResourceManager);\n\n    this._head = document.getElementsByTagName('head')[0];\n    this._cssPaths = {};\n    this._scriptMaps = {};\n    this._dataPromises = {};\n  }\n  /**\n   * Loads a javascript file.\n   * @param {string|Array} paths - The path to the view's js file\n   * @memberOf ResourceManager\n   * @return {Promise} Returns a promise that resolves when all scripts have been loaded\n   */\n\n\n  _createClass(ResourceManager, [{\n    key: \"loadScript\",\n    value: function () {\n      var _loadScript = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(paths) {\n        var _this = this;\n\n        var script, map, loadPromises;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loadPromises = [];\n                paths = ensurePathArray(paths);\n                paths.forEach(function (path) {\n                  map = _this._scriptMaps[path] = _this._scriptMaps[path] || {};\n\n                  if (!map.promise) {\n                    map.path = path;\n                    map.promise = new Promise(function (resolve) {\n                      script = _this.createScriptElement();\n                      script.setAttribute('type', 'text/javascript');\n                      script.src = path;\n                      script.addEventListener('load', resolve);\n\n                      _this._head.appendChild(script);\n                    });\n                  }\n\n                  loadPromises.push(map.promise);\n                });\n                return _context.abrupt(\"return\", Promise.all(loadPromises));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function loadScript(_x) {\n        return _loadScript.apply(this, arguments);\n      }\n\n      return loadScript;\n    }()\n    /**\n     * Removes a script that has the specified path from the head of the document.\n     * @param {string|Array} paths - The paths of the scripts to unload\n     * @memberOf ResourceManager\n     */\n\n  }, {\n    key: \"unloadScript\",\n    value: function () {\n      var _unloadScript = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(paths) {\n        var _this2 = this;\n\n        var file;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                  paths = ensurePathArray(paths);\n                  paths.forEach(function (path) {\n                    file = _this2._head.querySelectorAll('script[src=\"' + path + '\"]')[0];\n\n                    if (file) {\n                      _this2._head.removeChild(file);\n\n                      delete _this2._scriptMaps[path];\n                    }\n                  });\n                  resolve();\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function unloadScript(_x2) {\n        return _unloadScript.apply(this, arguments);\n      }\n\n      return unloadScript;\n    }()\n    /**\n     * Creates a new script element.\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createScriptElement\",\n    value: function createScriptElement() {\n      return document.createElement('script');\n    }\n    /**\n     * Makes a request to get data and caches it.\n     * @param {string} url - The url to fetch data from\n     * @param [reqOptions] - options to be passed to fetch call\n     * @returns {*}\n     */\n\n  }, {\n    key: \"fetchData\",\n    value: function () {\n      var _fetchData = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(url) {\n        var reqOptions,\n            cacheId,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                reqOptions = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                cacheId = url + JSON.stringify(reqOptions);\n                reqOptions.cache = reqOptions.cache === undefined ? true : reqOptions.cache;\n\n                if (url) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.resolve());\n\n              case 5:\n                if (!(!this._dataPromises[cacheId] || !reqOptions.cache)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                _context3.prev = 6;\n                _context3.next = 9;\n                return fetch(url, reqOptions);\n\n              case 9:\n                this._dataPromises[cacheId] = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](6);\n                // if failure, remove cache so that subsequent\n                // requests will trigger new ajax call\n                this._dataPromises[cacheId] = null;\n                throw _context3.t0;\n\n              case 16:\n                return _context3.abrupt(\"return\", this._dataPromises[cacheId]);\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[6, 12]]);\n      }));\n\n      function fetchData(_x3) {\n        return _fetchData.apply(this, arguments);\n      }\n\n      return fetchData;\n    }()\n    /**\n     * Loads css files.\n     * @param {Array|String} paths - An array of css paths files to load\n     * @memberOf ResourceManager\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"loadCss\",\n    value: function () {\n      var _loadCss = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(paths) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", new Promise(function (resolve) {\n                  paths = ensurePathArray(paths);\n                  paths.forEach(function (path) {\n                    // TODO: figure out a way to find out when css is guaranteed to be loaded,\n                    // and make this return a truely asynchronous promise\n                    if (!_this3._cssPaths[path]) {\n                      var el = document.createElement('link');\n                      el.setAttribute('rel', 'stylesheet');\n                      el.setAttribute('href', path);\n\n                      _this3._head.appendChild(el);\n\n                      _this3._cssPaths[path] = el;\n                    }\n                  });\n                  resolve();\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function loadCss(_x4) {\n        return _loadCss.apply(this, arguments);\n      }\n\n      return loadCss;\n    }()\n    /**\n     * Unloads css paths.\n     * @param {string|Array} paths - The css paths to unload\n     * @memberOf ResourceManager\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"unloadCss\",\n    value: function () {\n      var _unloadCss = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(paths) {\n        var _this4 = this;\n\n        var el;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", new Promise(function (resolve) {\n                  paths = ensurePathArray(paths);\n                  paths.forEach(function (path) {\n                    el = _this4._cssPaths[path];\n\n                    if (el) {\n                      _this4._head.removeChild(el);\n\n                      _this4._cssPaths[path] = null;\n                    }\n                  });\n                  resolve();\n                }));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function unloadCss(_x5) {\n        return _unloadCss.apply(this, arguments);\n      }\n\n      return unloadCss;\n    }()\n    /**\n     * Parses a template into a DOM element, then returns element back to you.\n     * @param {string} path - The path to the template\n     * @param {HTMLElement} [el] - The element to attach template to\n     * @returns {Promise} Returns a promise that resolves with contents of template file\n     */\n\n  }, {\n    key: \"loadTemplate\",\n    value: function () {\n      var _loadTemplate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(path, el) {\n        var contents;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (path) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n                _context6.next = 4;\n                return this.fetchTemplate(path);\n\n              case 4:\n                contents = _context6.sent;\n\n                if (!el) {\n                  _context6.next = 8;\n                  break;\n                }\n\n                el.innerHTML = contents;\n                return _context6.abrupt(\"return\", el);\n\n              case 8:\n                return _context6.abrupt(\"return\", contents);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function loadTemplate(_x6, _x7) {\n        return _loadTemplate.apply(this, arguments);\n      }\n\n      return loadTemplate;\n    }()\n    /**\n     * Fetches a template file from the server.\n     * @param [templatePath] - The file path to the template file\n     * @returns {Promise} Returns a promise that is resolved with the contents of the template file when retrieved\n     */\n\n  }, {\n    key: \"fetchTemplate\",\n    value: function () {\n      var _fetchTemplate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(templatePath) {\n        var resp;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return fetch(templatePath);\n\n              case 2:\n                resp = _context7.sent;\n                _context7.next = 5;\n                return resp.text();\n\n              case 5:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function fetchTemplate(_x8) {\n        return _fetchTemplate.apply(this, arguments);\n      }\n\n      return fetchTemplate;\n    }()\n    /**\n     * Removes all cached resources.\n     * @memberOf ResourceManager\n     */\n\n  }, {\n    key: \"flush\",\n    value: function () {\n      var _flush = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8() {\n        var s, map;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.unloadCss(Object.getOwnPropertyNames(this._cssPaths));\n\n              case 2:\n                this._cssPaths = {};\n                _context8.t0 = _regeneratorRuntime.keys(this._scriptMaps);\n\n              case 4:\n                if ((_context8.t1 = _context8.t0()).done) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                s = _context8.t1.value;\n\n                if (!this._scriptMaps.hasOwnProperty(s)) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                map = this._scriptMaps[s];\n                _context8.next = 10;\n                return this.unloadScript(map.path);\n\n              case 10:\n                _context8.next = 4;\n                break;\n\n              case 12:\n                this._scriptMaps = {};\n                this._dataPromises = {};\n\n              case 14:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function flush() {\n        return _flush.apply(this, arguments);\n      }\n\n      return flush;\n    }()\n  }]);\n\n  return ResourceManager;\n}();\n\nvar resourceManager = new ResourceManager();\nvar videos = new Map();\n\nvar YoutubeVideoElement =\n/*#__PURE__*/\nfunction (_HTMLElement) {\n  _inherits(YoutubeVideoElement, _HTMLElement);\n\n  function YoutubeVideoElement() {\n    var _this5;\n\n    _classCallCheck(this, YoutubeVideoElement);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(YoutubeVideoElement).call(this));\n    _this5.paused = true;\n    _this5.ytPlayerContainer = undefined;\n    _this5.resolveBuildPlayerPromise = null;\n    _this5.ytPlayerPromise = null;\n    _this5.scriptPath = 'https://www.youtube.com/iframe_api';\n    _this5.mediaError = undefined;\n    videos.set(_assertThisInitialized(_this5), _this5.id);\n    return _this5;\n  }\n\n  _createClass(YoutubeVideoElement, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      this.ytPlayerContainer = this.createYTPlayerElement();\n      this.appendChild(this.ytPlayerContainer);\n      this.ytPlayerContainer.style.display = 'block'; // to adhere to shape of youtube's generated iframe\n\n      this.load();\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      videos.delete(this);\n\n      if (this.resolveBuildPlayerPromise) {\n        this.resolveBuildPlayerPromise();\n      }\n\n      if (this.ytPlayer) {\n        this.ytPlayer.destroy();\n      }\n\n      if (!videos.size) {\n        videos.clear();\n        this.unloadYTScript();\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.loadYTScript();\n\n              case 2:\n                _context9.next = 4;\n                return this.buildPlayer();\n\n              case 4:\n                this.ytPlayer = _context9.sent;\n                return _context9.abrupt(\"return\", this.ytPlayer);\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"play\",\n    value: function play() {\n      this.paused = false;\n\n      if (!this.src) {\n        this.error = new Error(\"you cannot call play() method on a video element that has no youtube source url\");\n      } else if (this.ytPlayer) {\n        this.ytPlayer.playVideo();\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.ytPlayer) {\n        this.ytPlayer.pauseVideo();\n      }\n    }\n  }, {\n    key: \"createYTPlayerElement\",\n    value: function createYTPlayerElement() {\n      return document.createElement('div');\n    }\n  }, {\n    key: \"onPlay\",\n    value: function onPlay() {\n      var _this6 = this;\n\n      this.paused = false; // pause all other youtube videos from playing!\n\n      videos.forEach(function (id, video) {\n        if (video !== _this6 && !video.paused) {\n          video.pause();\n        }\n      });\n      this.dispatchEvent(new CustomEvent('play'));\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause() {\n      this.paused = true;\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd() {\n      this.paused = true;\n    }\n  }, {\n    key: \"_onYTApiStateChange\",\n    value: function _onYTApiStateChange(obj) {\n      var stateMap = {\n        '-1': 'unstarted',\n        '0': 'ended',\n        '1': 'playing',\n        '2': 'pause',\n        '3': 'buffering',\n        '5': 'cued'\n      };\n      var state = stateMap[obj.data.toString()]; // trigger our internal event handling method\n      // whenever the youtube api player triggers an event\n\n      var eventMethodMap = {\n        ended: this.onEnd,\n        pause: this.onPause,\n        playing: this.onPlay\n      };\n\n      if (eventMethodMap[state]) {\n        var method = eventMethodMap[state];\n\n        if (method) {\n          method.call(this); // TODO: trigger 'play' MediaEvent if the video has been paused at least once\n\n          this.dispatchEvent(new CustomEvent(state));\n        }\n      }\n    }\n  }, {\n    key: \"loadYTScript\",\n    value: function loadYTScript() {\n      var _this7 = this;\n\n      // Load the IFrame Player API code asynchronously.\n      if (!YoutubeVideoElement.scriptLoadPromise) {\n        YoutubeVideoElement.scriptLoadPromise = new Promise(function (resolve) {\n          // NOTE: youtube's iframe api ready only fires once after first script load\n          if (!window.onYouTubeIframeAPIReady) {\n            YoutubeVideoElement.triggerYoutubeIframeAPIReady = resolve;\n\n            window.onYouTubeIframeAPIReady = function () {\n              window.onYouTubeIframeAPIReady = null; // once the script loads once, we are guaranteed for it to\n              // be ready even after destruction of all instances (if consumer\n              // doesnt mangle with it)\n\n              YoutubeVideoElement.triggerYoutubeIframeAPIReady();\n            };\n          }\n\n          return resourceManager.loadScript(_this7.scriptPath);\n        });\n      }\n\n      return YoutubeVideoElement.scriptLoadPromise;\n    }\n  }, {\n    key: \"unloadYTScript\",\n    value: function unloadYTScript() {\n      resourceManager.unloadScript(this.scriptPath);\n      YoutubeVideoElement.scriptLoadPromise = null;\n    }\n  }, {\n    key: \"buildPlayer\",\n    value: function buildPlayer() {\n      var _this8 = this;\n\n      if (this.ytPlayerPromise) {\n        return this.ytPlayerPromise;\n      }\n\n      this.ytPlayerPromise = new Promise(function (resolve) {\n        var playerOptions = {\n          events: {\n            onError: function onError() {\n              _this8.error = new Error('player could not be built');\n            },\n            onReady: function onReady(e) {\n              _this8.dispatchEvent(new CustomEvent('loadstart'));\n\n              _this8.dispatchEvent(new CustomEvent('canplay'));\n\n              _this8.resolveBuildPlayerPromise = resolve;\n              resolve(e.target);\n            },\n            onStateChange: function onStateChange(obj) {\n              return _this8._onYTApiStateChange(obj);\n            }\n          },\n          height: _this8.height,\n          playerVars: _this8.ytPlayerVars,\n          videoId: _this8.videoId,\n          width: _this8.width\n        };\n        _this8.ytPlayer = new YT.Player( // @ts-ignore\n        _this8.ytPlayerContainer, playerOptions);\n      });\n      return this.ytPlayerPromise;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return Number(this.getAttribute('height'));\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return Number(this.getAttribute('width'));\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return this.getAttribute('src');\n    }\n  }, {\n    key: \"autoplay\",\n    get: function get() {\n      return this.hasAttribute('autoplay');\n    }\n  }, {\n    key: \"playsinline\",\n    get: function get() {\n      return this.hasAttribute('playsinline');\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.getAttribute('id') || \"ytPlayer-\".concat(videos.size);\n    }\n  }, {\n    key: \"controls\",\n    get: function get() {\n      return this.hasAttribute('controls') || true;\n    }\n  }, {\n    key: \"ytPlayerVars\",\n    get: function get() {\n      var srcQueryParams = this.srcQueryParams;\n      srcQueryParams.autoplay = this.autoplay ? 1 : 0;\n      srcQueryParams.controls = this.controls ? 1 : 0;\n      srcQueryParams.playsinline = this.playsinline ? 1 : 0;\n      return srcQueryParams;\n    }\n  }, {\n    key: \"srcQueryParams\",\n    get: function get() {\n      var queryString = this.src.split('?')[1] || '';\n\n      if (!queryString) {\n        return {};\n      }\n\n      var a = queryString.split('&');\n      var params = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = a[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var item = _step.value;\n          var p = item.split('=', 2);\n\n          if (p.length === 1) {\n            params[p[0]] = '';\n          } else {\n            params[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, ' '));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return params;\n    }\n  }, {\n    key: \"videoId\",\n    get: function get() {\n      var re = new RegExp(\"https?:\\\\/\\\\/(?:[0-9A-Z-]+\\\\.)?(?:youtu\\\\.be\\\\/|youtube(?:-nocookie)?\\\\.com\\\\S*[^\\\\w\\\\s-])([\\\\w-]{11})(?=[^\\\\w-]|$)(?![?=&+%\\\\w.-]*(?:['\\\"][^<>]*>|<\\\\/a>))[?=&+%\\\\w.-]*\", 'ig');\n      return this.src.replace(re, '$1');\n    }\n  }, {\n    key: \"error\",\n    set: function set(error) {\n      var message = error.message;\n      this.dispatchEvent(new ErrorEvent(message));\n      this.mediaError = error;\n      throw error;\n    },\n    get: function get() {\n      return this.mediaError;\n    }\n  }]);\n\n  return YoutubeVideoElement;\n}(_wrapNativeSuper(HTMLElement));\n\nYoutubeVideoElement.scriptLoadPromise = null;\nYoutubeVideoElement.triggerYoutubeIframeAPIReady = null;\ncustomElements.define('youtube-video', YoutubeVideoElement);\nexport { YoutubeVideoElement };","map":null,"metadata":{},"sourceType":"module"}